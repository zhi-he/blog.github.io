<?xml version="1.0" encoding="utf-8" standalone="yes"?><search><entry><title>关于我</title><url>/about/</url><categories/><tags/><content type="html"> 个人简历 前端工程师 个人简介 男 1995年4月 本科 年工作经验 176****6082 73****34@qq.com 籍贯：内蒙古赤峰市 教育经历 2013.09 - 2017.06 本科 南阳理工学院 网络工程
个人技能 精通 VueJs、ReactJs开发单页面应用， webpack 打包， npm 库的使用 精通 jQuery 进行 DOM 操作，编写动画 精通 JavaScript， CSS 浏览器兼容性解决方案，能够解决多浏览器版本兼容问题 精通 HTML 和 CSS 进行网站的布局，且善于 SEO 优化 精通微信小程序开发，使用原生、WEPY和uni-app开发小程序 熟练运用 VSCode、 Sublime、 HBuiler、 WebStorm等编程工具 熟悉使用MidWay、NextJs、NestJs、eggjs开发Serverless与服务端 熟悉 Photoshop 的基本操作 熟悉 JSON 数据格式，熟练使用 Ajax、 JSONP、 CORS 跨域 用过 Animate.css，Swiper.js， lodash， Touch.js， fullPage.js， scrollPic.js， moment.js，lodash 等插件 用过 vant、Element、AntDesign、uni-app、WeUI、iView、bootstrap、wepy、Ant Design等框架 熟悉 MySQL 数据库的基本操作 工作经历 2020.05 – 至今 大方云图 驻高德 前端工程师 负责CRM、BOSS、高德开放平台控制台三个平台日常维护和升级迭代，使用Midway、ReactJs技术栈，umi应用框架和Ant Design UI库。CRM平台是供商务、财务同学等创建线索、客户、项目、合同、订单、发票的运营平台；BOSS平台是账号、接口等相关设置管理，如配额、权限、仪表盘等的操作平台；开放平台控制台是基于微前端框架重构的LBS官网控制台，供注册的开发者使用。
2020.06 – 2021.05 德科信息 驻vivo前端工程师 问答社区开发升级迭代，使用Nest.js + Next.js开发社区H5，维护升级社区的快应用，对接vivo手机负一屏卡片、全搜、以及语音助手，快应用已上线至vivo、小米、华为、oppo等手机快应用中心，使 …</content></entry><entry><title>树结构的遍历</title><url>/frontend/tree_traversal/</url><categories><category>javascript</category></categories><tags/><content type="html"><![CDATA[  树的结构 let tree = [ { value: &#39;1&#39;, label: &#39;节点1&#39;, children: [ { value: &#39;1-1&#39;, label: &#39;节点1-1&#39; }, { value: &#39;1-2&#39;, label: &#39;节点1-2&#39; } ] }, { value: &#39;2&#39;, label: &#39;节点2&#39;, children: [ { value: &#39;2-1&#39;, label: &#39;节点2-1&#39; } ] }, ... ] 查找节点 function treeEach (tree, func) { let node, list = [...tree] while (node = list.shift()) { if (func(node)) { return node } node.children &amp;&amp; list.push(...node.children) } } 应用上面的代码，查找value为'1-1&rsquo;的节点
treeEach(tree, (node) =&gt; node.value === &#39;1-1&#39;) 树转化为列表 function treeToList (tree, res = []) { tree.forEach(node =&gt; { res.push(node) node.children &amp;&amp; treeToList(node.children, res) }) return res } 执行上面的代码，得到如下结构：
let list = treeToList (tree); cosnole.log(list) // 输出 [ { value: &#39;1&#39;, label: &#39;节点1&#39;, }, { value: &#39;1-1&#39;, label: &#39;节点1-1&#39;, }, { value: &#39;1-2&#39;, label: &#39;节点1-2&#39;, }, { value: &#39;2&#39;, label: &#39;节点2&#39;, }, { value: &#39;2-1&#39;, label: &#39;节点2-1&#39;, } ] 查找树节点路径 采用回溯法的思想，使用先序遍历，维护一个队列存储路径上每个节点的id，假设节点就在当前分支，如果当前分支查不到，则回溯。
function treeFindPath (tree, func, path = []) { if (!tree) return [] for (const data of tree) { path.push(data.id) if (func(data)) return path if (data.children) { const findChildren = treeFindPath(data.children, func, path) findChildren.length &amp;&amp; return findChildren } path.pop() } return [] }   ]]></content></entry><entry><title>11. 盛最多水的容器「力扣」</title><url>/frontend/11__container_with_most_water/</url><categories><category>javascript</category></categories><tags/><content type="html"> 题目描述 给定一个长度为 n 的整数数组 height 。有 n 条垂线，第 i 条线的两个端点是 (i, 0) 和 (i, height[i]) 。
找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。
返回容器可以储存的最大水量。
说明：你不能倾斜容器。
示例 1: 输入：[1,8,6,2,5,4,8,3,7] 输出：49 解释：图中垂直线代表输入数组 [1,8,6,2,5,4,8,3,7]。在此情况下，容器能够容纳水（表示为蓝色部分）的最大值为 49。 示例 2:
输入：height = [1,1] 输出：1 解题 可以看做示例一中计算蓝色矩形面积，如示例一中：长为x轴下标 (9 - 2)，宽为 x 轴 2 和 9 处 height(i) 最短的 7，得到(9 - 2) * 7 = 49
分析👇
从两边开始算起，矩形的长为 r - l，宽为 Math.min(height[l], height[r])，则area等于 Math.min(height[l], height[r]) * (r - l)
划重点当 height[r] 大于 height[l]，左下标 l 右移，否则 r 左移
因矩形面积受制于最短边的情况，只能优先保留最长的边 height[r]，先移动 l，再移动 r 才能矩形最大
源码如下：
/** * @param {number[]} height * @return {number} */ var maxArea = function(height) { let area = 0, l = 0, r = height.length - 1 while (l &amp;lt; r) { area = Math.max( area, Math.min(height[l], height[r]) * (r - l) ) height[r] &amp;gt; height[l] ? l++ : r-- } return area };</content></entry><entry><title>12. 整数转罗马数字「力扣」</title><url>/frontend/12__integer_to_roman/</url><categories><category>javascript</category></categories><tags/><content type="html"><![CDATA[  题目描述 七个不同的符号代表罗马数字，其值如下：
符号 值 I 1 V 5 X 10 L 50 C 100 D 500 M 1000 罗马数字是通过添加从最高到最低的小数位值的转换而形成的。将小数位值转换为罗马数字有以下规则：
如果该值不是以 4 或 9 开头，请选择可以从输入中减去的最大值的符号，将该符号附加到结果，减去其值，然后将其余部分转换为罗马数字。 如果该值以 4 或 9 开头，使用 减法形式，表示从以下符号中减去一个符号，例如 4 是 5 (V) 减 1 (I): IV ，9 是 10 (X) 减 1 (I)：IX。仅使用以下减法形式：4 (IV)，9 (IX)，40 (XL)，90 (XC)，400 (CD) 和 900 (CM)。 只有 10 的次方（I, X, C, M）最多可以连续附加 3 次以代表 10 的倍数。你不能多次附加 5 (V)，50 (L) 或 500 (D)。如果需要将符号附加4次，请使用 减法形式。 给定一个整数，将其转换为罗马数字。 示例 1:
输入：num = 3749 输出：&#34;MMMDCCXLIX&#34; 解释： 3000 = MMM 由于 1000 (M) + 1000 (M) + 1000 (M) 700 = DCC 由于 500 (D) + 100 (C) + 100 (C) 40 = XL 由于 50 (L) 减 10 (X) 9 = IX 由于 10 (X) 减 1 (I) 注意：49 不是 50 (L) 减 1 (I) 因为转换是基于小数位。 示例 2:
输入：num = 58 输出：&#34;LVIII&#34; 解释： 50 = L 8 = VIII 示例 3:
输入：num = 1994 输出：&#34;MCMXCIV&#34; 解释： 1000 = M 900 = CM 90 = XC 4 = IV 解题 分析👇
源码如下：
/** * @param {number} num * @return {string} */ var intToRoman = function(num) { const conf = { 1: &#39;I&#39;, 4: &#39;IV&#39;, 5: &#39;V&#39;, 9: &#39;IX&#39;, 10: &#39;X&#39;, 40: &#39;XL&#39;, 50: &#39;L&#39;, 90: &#39;XC&#39;, 100: &#39;C&#39;, 400: &#39;CD&#39;, 500: &#39;D&#39;, 900: &#39;CM&#39;, 1000: &#39;M&#39;, } const strNum = String(num) const nArr = Object.keys(conf).sort((a, b) =&gt; b - a) let roman = &#39;&#39; for(let i = 0, len = strNum.length; i &lt; len; i++) { // 由左到右依次获取，如：567，依次为：500， 60， 7 let current = +strNum[i] * Math.pow(10 , len - i - 1) while(current &gt; 0) { // 获取当前位数匹配罗马数字对应的数字 const key = nArr.find(n =&gt; current &gt;= n) // 拼接罗马数字 roman += conf[key] // 减去匹配到罗马数字对应的数字， 重置current的值， current -= key } } return roman };```   ]]></content></entry><entry><title>5. 最长回文子串「力扣」</title><url>/frontend/5__longest_alindrome/</url><categories><category>javascript</category></categories><tags/><content type="html"><![CDATA[  题目描述 给你一个字符串 s，找到 s 中最长的回文子串。
如果字符串的反序与原始字符串相同，则该字符串称为回文字符串。
示例 1:
输入：s = &#34;babad&#34; 输出：&#34;bab&#34; 解释：&#34;aba&#34; 同样是符合题意的答案。 示例 2:
输入：s = &#34;cbbd&#34; 输出：&#34;bb&#34; 解题 回文字符串，无非有两种类型，ada和baab，分为奇偶长度两种。
单考虑偶数的话，如下：
分析👇
// 现有一字符串 str const str = &#39;cbaabc&#39; // 当 str[2]===str[3] str[1]===str[4] str[0]===str[5] // 则 str 为回文字符串 有没有看出什么规律，左侧的下标做减法，右侧的下标做加法。只要都相等，即是回文字符串！
源码如下：
var longestPalindrome = function(s) { let str = &#39;&#39; if(s.length &lt; 2) return s for(let i = 0, len = s.length; i &lt; len; i++) { let l1 = i, r1 = i let l2 = i, r2 = i + 1 // 判断奇数长度的 while(l1 &gt; -1 &amp;&amp; r1 &lt; len &amp;&amp; s[l1] === s[r1]) { r1 - l1 + 1 &gt; str.length &amp;&amp; (str = s.slice(l1, r1 + 1)) l1-- r1++ } // 判断偶数长度的 while(l2 &gt; -1 &amp;&amp; r2 &lt; len &amp;&amp; s[l2] === s[r2]) { r2 - l2 + 1 &gt; str.length &amp;&amp; (str = s.slice(l2, r2 + 1)) l2-- r2++ } } return str };   ]]></content></entry><entry><title>3.无重复字符的最长子串「力扣」</title><url>/frontend/3__length_of_longest_substring/</url><categories><category>javascript</category></categories><tags/><content type="html"><![CDATA[  题目描述 无重复字符的最长子串，给定一个字符串 s ，请你找出其中不含有重复字符的 最长子串 的长度。
示例 1:
输入: s = &#34;abcabcbb&#34; 输出: 3 解释: 因为无重复字符的最长子串是 &#34;abc&#34;，所以其长度为 3。 示例 2:
输入: s = &#34;bbbbb&#34; 输出: 1 解释: 因为无重复字符的最长子串是 &#34;b&#34;，所以其长度为 1。 示例 3:
输入: s = &#34;pwwkew&#34; 输出: 3 解释: 因为无重复字符的最长子串是 &#34;wke&#34;，所以其长度为 3。 请注意，你的答案必须是 子串 的长度，&#34;pwke&#34; 是一个子序列，不是子串。 解题 使用滑动窗口依次罗列出无重复子字符串集合，在判断最长的子串，以abcabcbb为例，类似如下；
abcabcbb 长度：1 ^ abcabcbb 长度：2 ^^ abcabcbb 长度：3 ^ ^ abcabcbb 出现重复 ^ ^ abcabcbb 长度：1 ^ abcabcbb 长度：2 ^^ abcabcbb 长度：3 ^ ^ abcabcbb 出现重复 ^ ^ abcabcbb 长度：1 ^ abcabcbb 长度：2 ^^ abcabcbb 长度：2 ^ ^ abcabcbb 出现重复 ^ ^ ... 不是最优解，但可以实现，源码如下：
/** * @param {string} * @return {number} */ var lengthOfLongestSubstring = function(s) { let num = 0 for (let i = 0, len = s.length; i &lt; len; i++){ for (let j = i + 1; j &lt;= len; j++) { const str = s.slice(i, j) // 判断当前字符串中是否有重复字符，通过Set的特性转成数组直接去重 if (str.length == [...new Set(str.split(&#39;&#39;))].length) { num = Math.max(str.length, num) } else { // 当出现重复，窗口左侧右移 i++ } } } return num };   ]]></content></entry><entry><title>1.两数之和「力扣」</title><url>/frontend/1__two_sum/</url><categories><category>javascript</category></categories><tags/><content type="html"><![CDATA[  题目描述 两数之和 给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 target 的那 两个 整数，并返回它们的数组下标。 你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。
你可以按任意顺序返回答案。
示例 1：
输入：nums = [2,7,11,15], target = 9 输出：[0,1] 解释：因为 nums[0] + nums[1] == 9 ，返回 [0, 1] 。 示例 2：
输入：nums = [3,2,4], target = 6 输出：[1,2] 示例 3：
&gt;输入：nums = [3,3], target = 6 &gt;输出：[0,1] 解题 暴力求解，两层for循环，根据两数之和，得到下标。 /** * @param {number[]} nums * @param {number} target * @return {number[]} */ var twoSum = function(nums, target) { for(let i = 0, len = nums.length; i &lt; len;i++) { for(let j = i + 1; j &lt; len; j++) { if(nums[i] + nums[j] === target){ return [i, j] } } } }; 逆向思维，一层for循环，通过两数相减得到另一个数，去寻找下标。 /** * @param {number[]} nums * @param {number} target * @return {number[]} */ var twoSum = function(nums, target) { for(let i = 0, len = nums.length; i &lt; len; i++) { const num2 = target - nums[i] const idx = nums.findIndex(n =&gt; n === num2) if (idx &gt; -1 &amp;&amp; idx !== i) { return [i, idx] } } };   ]]></content></entry><entry><title>21.使用游标「SQL必知必会 第5版」</title><url>/database/21__using_cursors/</url><categories><category>SQL</category></categories><tags><tag>SQL必知必会</tag><tag>sql</tag><tag>MySQL</tag></tags><content type="html"> 前言 本系列是个人看 《SQL必知必会（第5版）》 的记录，需要的数据可以通过 建表 和 导入数据 下载导入.
正文 这一课将讲授什么是游标，如何使用游标。
游标 SQL 检索操作返回一组称为结果集的行，这组返回的行都是与 SQL 语句相匹配的行（零行或多行）。简单地使用 SELECT语句，没有办法得到第一行、下一行或前 10 行。但这是关系 DBMS 功能的组成部分。
结果集（result set）
SQL 查询所检索出的结果。
有时，需要在检索出来的行中前进或后退一行或多行，这就是游标的用途所在。游标（cursor）是一个存储在 DBMS 服务器上的数据库查询，它不是一条 SELECT 语句，而是被该语句检索出来的结果集。在存储了游标之后，应用程序可以根据需要滚动或浏览其中的数据。
不同的 DBMS 支持不同的游标选项和特性。常见的一些选项和特性如下。
能够标记游标为只读，使数据能读取，但不能更新和删除。 能控制可以执行的定向操作（向前、向后、第一、最后、绝对位置、相对位置等）。 能标记某些列为可编辑的，某些列为不可编辑的。 规定范围，使游标对创建它的特定请求（如存储过程）或对所有请求可访问。 指示 DBMS 对检索出的数据（而不是指出表中活动数据）进行复制，使数据在游标打开和访问期间不变化。 说明：具体 DBMS 的支持
Microsoft Access 不支持游标，所以本课的内容不适用于 Microsoft Access。
MySQL 5 已经支持存储过程。因此，本课的内容不适用 MySQL 较早的版本。
SQLite支持的游标称为步骤（step），本课讲述的基本概念适用于SQLite 的步骤，但语法可能完全不同。
游标主要用于交互式应用，其中用户需要滚动屏幕上的数据，并对数据进行浏览或做出更改。
说明：游标与基于 Web 的应用
游标对基于 Web 的应用（如 ASP、ASP.NET、ColdFusion、PHP、Python、Ruby、JSP 等）用处不大。虽然游标在客户端应用和服务器会话期间存在，但这种客户/服务器模式不适合 Web 应用，因为应用服务器是数据库客户端而不是最终用户。所以，大多数 Web 应用开发人员不使用游标，他们根据自己的需要重新开发相应的功能。
使用游标 使用游标涉及几个明确的步骤。
在使用游标前，必须声明（定义）它。这个过程实际 …</content></entry><entry><title>20.管理事务处理「SQL必知必会 第5版」</title><url>/database/20__managing_transaction_processing/</url><categories><category>SQL</category></categories><tags><tag>SQL必知必会</tag><tag>sql</tag><tag>MySQL</tag></tags><content type="html"> 前言 本系列是个人看 《SQL必知必会（第5版）》 的记录，需要的数据可以通过 建表 和 导入数据 下载导入.
正文 这一课介绍什么是事务处理，如何利用 COMMIT 和 ROLLBACK语句管理事务处理。
事务处理 使用事务处理（transaction processing），通过确保成批的 SQL 操作要么完全执行，要么完全不执行，来维护数据库的完整性。
正如 第 12 课 所述，关系数据库把数据存储在多个表中，使数据更容易操纵、维护和重用。不用深究如何以及为什么进行关系数据库设计，在某种程度上说，设计良好的数据库模式都是关联的。
前面使用的 Orders 表就是一个很好的例子。订单存储在 Orders 和 OrderItems 两个表中：Orders 存储实际的订单，OrderItems 存储订购的各项物品。这两个表使用称为主键（参阅 第 1 课 ）的唯一 ID 互相关联，又与包含客户和产品信息的其他表相关联。
给系统添加订单的过程如下：
检查数据库中是否存在相应的顾客，如果不存在，添加他； 检索顾客的 ID； 在 Orders表添加一行，它与顾客 ID 相关联； 检索 Orders表中赋予的新订单 ID； 为订购的每个物品在 OrderItems表中添加一行，通过检索出来的 ID
把它与 Orders表关联（并且通过产品 ID 与 Products表关联）。 现在假设由于某种数据库故障（如超出磁盘空间、安全限制、表锁等），这个过程无法完成。数据库中的数据会出现什么情况？
如果故障发生在添加顾客之后，添加 Orders 表之前，则不会有什么问题。某些顾客没有订单是完全合法的。重新执行此过程时，所插入的顾客记录将被检索和使用。可以有效地从出故障的地方开始执行此过程。
但是，如果故障发生在插入 Orders行之后，添加 OrderItems行之前，怎么办？现在，数据库中有一个空订单。
更糟的是，如果系统在添加 OrderItems 行之时出现故障，怎么办？结果是数据库中存在不完整的订单，而你还不知道。
如何解决这种问题？这就需要使用事务处理了。事务处理是一种机制，用来管理必须成批执行的 SQL 操作，保证数据库不包含不完整的操作结果。利用事务处理，可以保证一组操作不会中途停止，它们要么完全执行，要么完全不执行（除非明确指示）。如果没有错误发生，整组语句提交给（写 …</content></entry><entry><title>19.使用存储过程「SQL必知必会 第5版」</title><url>/database/19__working_with_stored_procedures/</url><categories><category>SQL</category></categories><tags><tag>SQL必知必会</tag><tag>sql</tag><tag>MySQL</tag></tags><content type="html"> 前言 本系列是个人看 《SQL必知必会（第5版）》 的记录，需要的数据可以通过 建表 和 导入数据 下载导入.
正文 这一课介绍什么是存储过程，为什么要使用存储过程，如何使用存储过程，以及创建和使用存储过程的基本语法。
存储过程 迄今为止，我们使用的大多数 SQL 语句都是针对一个或多个表的单条语句。并非所有操作都这么简单，经常会有一些复杂的操作需要多条语句才能完成，例如以下的情形。
为了处理订单，必须核对以保证库存中有相应的物品。 如果物品有库存，需要预定，不再出售给别的人，并且减少物品数据以反映正确的库存量。 库存中没有的物品需要订购，这需要与供应商进行某种交互。 关于哪些物品入库（并且可以立即发货）和哪些物品退订，需要通知相应的顾客。 这显然不是一个完整的例子，它甚至超出了本书中所用样例表的范围，但足以表达我们的意思了。执行这个处理需要针对许多表的多条 SQL 语句。此外，需要执行的具体 SQL 语句及其次序也不是固定的，它们可能会根据物品是否在库存中而变化。
那么，怎样编写代码呢？可以单独编写每条 SQL 语句，并根据结果有条件地执行其他语句。在每次需要这个处理时（以及每个需要它的应用中），都必须做这些工作。
可以创建存储过程。简单来说，存储过程就是为以后使用而保存的一条或多条 SQL 语句。可将其视为批文件，虽然它们的作用不仅限于批处理。
说明：具体 DBMS 的支持
Microsoft Access 和 SQLite 不支持存储过程。因此，本课的内容不适用它们。
MySQL 5 已经支持存储过程。因此，本课的内容不适用 MySQL 较早的版本。
说明：还有更多内容
存储过程很复杂，全面介绍它需要很大篇幅。本课不打算讲解存储过程的所有内容，只给出简单介绍，让读者对它们的功能有所了解。因此，这里给出的例子只提供 Oracle 和 SQL Server 的语法。
为什么要使用存储过程 我们知道了什么是存储过程，那么为什么要使用它们呢？理由很多，下面列出一些主要的。
通过把处理封装在一个易用的单元中，可以简化复杂的操作（如前面例子所述）。 由于不要求反复建立一系列处理步骤，因而保证了数据的一致性。如果所有开发人员和应用程序都使用同一存储过程，则所使用的代码都是相同的。
这一点的延伸就是防止错误。需要执行的步骤越多，出错的可能性就越大。防止错误保证了数据的一致性。 …</content></entry><entry><title>18.使用视图「SQL必知必会 第5版」</title><url>/database/18__using_views/</url><categories><category>SQL</category></categories><tags><tag>SQL必知必会</tag><tag>sql</tag><tag>MySQL</tag></tags><content type="html"><![CDATA[  前言 本系列是个人看 《SQL必知必会（第5版）》 的记录，需要的数据可以通过 建表 和 导入数据 下载导入.
正文 这一课将介绍什么是视图，它们怎样工作，何时使用它们；还将讲述如何利用视图简化前几课中执行的某些 SQL 操作。
视图 视图是虚拟的表。与包含数据的表不一样，视图只包含使用时动态检索数据的查询。
说明：DBMS 支持
Microsoft Access 不支持视图，没有与 SQL 视图一致的工作方式。因此，这一课的内容不适用 Microsoft Access。
MySQL 从版本 5 起开始支持视图，因此，这一课的内容不适用较早版本的 MySQL。
SQLite 仅支持只读视图，所以视图可以创建，可以读，但其内容不能更改。
理解视图的最好方法是看例子。 第 12 课 用下面的SELECT语句从三个表中检索数据：
输入👇🏻
SELECT cust_name, cust_contact FROM Customers, Orders, OrderItems WHERE Customers.cust_id = Orders.cust_id AND OrderItems.order_num = Orders.order_num AND prod_id = &amp;#39;RGAN01&amp;#39;; 此查询用来检索订购了某种产品的顾客。任何需要这个数据的人都必须理解相关表的结构，知道如何创建查询和对表进行联结。检索其他产品（或多个产品）的相同数据，必须修改最后的 WHERE 子句。
现在，假如可以把整个查询包装成一个名为 ProductCustomers 的虚拟表，则可以如下轻松地检索出相同的数据：
输入👇🏻
SELECT cust_name, cust_contact FROM ProductCustomers WHERE prod_id = &amp;#39;RGAN01&amp;#39;; 这就是视图的作用。ProductCustomers 是一个视图，作为视图，它不包含任何列或数据，包含的是一个查询（与上面用以正确联结表的相同查询）。
提示：DBMS 的一致支持
我们欣慰地了解到，所有 DBMS 非常一致地支持视图创建语法。
为什么使用视图 我们已经看到了视图应用的一个例子。下面是视图的一些常见应用。
重用 SQL 语句。 简化复杂的 SQL 操作。在编写查询后，可以方便地重用它而 …  ]]></content></entry><entry><title>17.创建和操纵表「SQL必知必会 第5版」</title><url>/database/17__creating_and_manipulating_tables/</url><categories><category>SQL</category></categories><tags><tag>SQL必知必会</tag><tag>sql</tag><tag>MySQL</tag></tags><content type="html"> 前言 本系列是个人看 《SQL必知必会（第5版）》 的记录，需要的数据可以通过 建表 和 导入数据 下载导入.
正文 这一课讲授创建、更改和删除表的基本知识。
创建表 SQL 不仅用于表数据操纵，还用来执行数据库和表的所有操作，包括表本身的创建和处理。
一般有两种创建表的方法：
多数 DBMS 都具有交互式创建和管理数据库表的工具； 表也可以直接用 SQL 语句操纵。 用程序创建表，可以使用 SQL 的 CREATE TABLE语句。需要注意的是，使用交互式工具时实际上就是使用 SQL 语句。这些语句不是用户编写的，界面工具会自动生成并执行相应的 SQL 语句（更改已有的表时也是这样）。
注意：语法差别
在不同的 SQL 实现中，CREATE TABLE语句的语法可能有所不同。对于具体的 DBMS 支持何种语法，请参阅相应的文档。
这一课不会介绍创建表时可以使用的所有选项，那超出了本课的范围，我只给出一些基本选项。详细的信息说明，请参阅具体的 DBMS 文档。
表创建基础 利用 CREATE TABLE创建表，必须给出下列信息：
新表的名字，在关键字 CREATE TABLE之后给出； 表列的名字和定义，用逗号分隔； 有的 DBMS 还要求指定表的位置。 下面的 SQL 语句创建本书中所用的 Products表： 输入👇🏻
CREATE TABLE Products ( prod_id CHAR(10) NOT NULL, vend_id CHAR(10) NOT NULL, prod_name CHAR(254) NOT NULL, prod_price DECIMAL(8,2) NOT NULL, prod_desc VARCHAR(1000) NULL ); 分析👇🏻 从上面的例子可以看到，表名紧跟 CREATE TABLE 关键字。实际的表定义（所有列）括在圆括号之中，各列之间用逗号分隔。这个表由 5 列组成。每列的定义以列名（它在表中必须是唯一的）开始，后跟列的数据类型（关于数据类型的解释，请参阅 第 1 课 ，整条语句以圆括号后的分号结束。
前面提到，不同 DBMS 的 CREATE TABLE的语法有所不同，这个简单脚本也说明了这一点。这条语句在 Oracle、PostgreSQL、SQL Server 和 SQLite 中有效， …</content></entry><entry><title>16.更新或删除数据「SQL必知必会 第5版」</title><url>/database/16__updating_and_deleting_data/</url><categories><category>SQL</category></categories><tags><tag>SQL必知必会</tag><tag>sql</tag><tag>MySQL</tag></tags><content type="html"><![CDATA[  前言 本系列是个人看 《SQL必知必会（第5版）》 的记录，需要的数据可以通过 建表 和 导入数据 下载导入.
正文 这一课介绍如何利用 UPDATE 和 DELETE 语句进一步操作表数据。
更新数据 更新（修改）表中的数据，可以使用UPDATE语句。有两种使用UPDATE的方式：
更新表中的特定行； 更新表中的所有行。 下面分别介绍。
注意：不要省略 WHERE 子句
在使用UPDATE 时一定要细心。因为稍不注意，就会更新表中的所有行。使用这条语句前，请完整地阅读本节。
提示：UPDATE 与安全
在客户端/服务器的 DBMS 中，使用UPDATE语句可能需要特殊的安全权限。在你使用UPDATE前，应该保证自己有足够的安全权限。
使用 UPDATE 语句非常容易，甚至可以说太容易了。基本的 UPDATE 语句由三部分组成，分别是：
要更新的表； 列名和它们的新值； 确定要更新哪些行的过滤条件。 举一个简单例子。客户 1000000005 现在有了电子邮件地址，因此他的记录需要更新，语句如下：
输入👇🏻
UPDATE Customers SET cust_email = &amp;#39;kim@thetoystore.com&amp;#39; WHERE cust_id = &amp;#39;1000000005&amp;#39;; UPDATE语句总是以要更新的表名开始。在这个例子中，要更新的表名为 Customers。SET命令用来将新值赋给被更新的列。在这里，SET子句设置 cust_email列为指定的值：
SET cust_email = &amp;#39;kim@thetoystore.com&amp;#39; UPDATE语句以 WHERE子句结束，它告诉 DBMS 更新哪一行。没有 WHERE 子句，DBMS 将会用这个电子邮件地址更新 Customers表中的所有行，这不是我们希望的。
更新多个列的语法稍有不同：
输入👇🏻
UPDATE Customers SET cust_contact = &amp;#39;Sam Roberts&amp;#39;, cust_email = &amp;#39;sam@toyland.com&amp;#39; WHERE cust_id = &amp;#39;1000000006&amp;#39;; 在更新多个列时，只需要使用一条 SET 命令，每个“列=值”对之间用逗号分隔（最后一列之后不用逗 …  ]]></content></entry><entry><title>15.插入数据「SQL必知必会 第5版」</title><url>/database/15__inserting_data/</url><categories><category>SQL</category></categories><tags><tag>SQL必知必会</tag><tag>sql</tag><tag>MySQL</tag></tags><content type="html"><![CDATA[  前言 本系列是个人看 《SQL必知必会（第5版）》 的记录，需要的数据可以通过 建表 和 导入数据 下载导入.
正文 这一课介绍如何利用 SQL 的 INSERT 语句将数据插入表中。
数据插入 毫无疑问，SELECT是最常用的 SQL 语句了，这就是前 14 课都在讲它的原因。但是，还有其他 3 个常用的 SQL 语句需要学习。第一个就是 INSERT（下一课介绍另外两个）。
顾名思义，INSERT用来将行插入（或添加）到数据库表。插入有几种方式：
插入完整的行； 插入行的一部分； 插入某些查询的结果。 下面逐一介绍这些内容。
提示：插入及系统安全
使用 INSERT 语句可能需要客户端/服务器 DBMS 中的特定安全权限。在你试图使用 INSERT前，应该保证自己有足够的安全权限。
插入完整的行 把数据插入表中的最简单方法是使用基本的 INSERT 语法，它要求指定表名和插入到新行中的值。下面举一个例子：
输入👇🏻
INSERT INTO Customers VALUES(1000000006, &amp;#39;Toy Land&amp;#39;, &amp;#39;123 Any Street&amp;#39;, &amp;#39;New York&amp;#39;, &amp;#39;NY&amp;#39;, &amp;#39;11111&amp;#39;, &amp;#39;USA&amp;#39;, NULL, NULL); 分析👇🏻
这个例子将一个新顾客插入到 Customers表中。存储到表中每一列的数据在 VALUES 子句中给出，必须给每一列提供一个值。如果某列没有值，如上面的 cust_contact 和 cust_email列，则应该使用 NULL值（假定表允许对该列指定空值）。各列必须以它们在表定义中出现的次序填充。
提示：INTO 关键字
在某些 SQL 实现中，跟在 INSERT 之后的 INTO 关键字是可选的。但是，即使不一定需要，最好还是提供这个关键字，这样做将保证 SQL 代码在 DBMS 之间可移植。
虽然这种语法很简单，但并不安全，应该尽量避免使用。上面的 SQL 语句高度依赖于表中列的定义次序，还依赖于其容易获得的次序信息。即使可以得到这种次序信息，也不能保证各列在下一次表结构变动后保持完全相同的次序。因此，编写依赖于特定列次序的 SQL 语句是很不安全的，这样做迟早会出问题。
编写 INSERT 语句的更安全（不 …  ]]></content></entry><entry><title>14.组合查询「SQL必知必会 第5版」</title><url>/database/14__combining_queries/</url><categories><category>SQL</category></categories><tags><tag>SQL必知必会</tag><tag>sql</tag><tag>MySQL</tag></tags><content type="html"><![CDATA[  前言 本系列是个人看 《SQL必知必会（第5版）》 的记录，需要的数据可以通过 建表 和 导入数据 下载导入.
正文 本课讲述如何利用 UNION 操作符将多条 SELECT 语句组合成一个结果集。
组合查询 多数 SQL 查询只包含从一个或多个表中返回数据的单条 SELECT语句。 但是，SQL也允许执行多个查询（多条SELECT语句），并将结果作为一个查询结果集返回。这些组合查询通常称为并（union）或复合查询（compound query）。
主要有两种情况需要使用组合查询：
在一个查询中从不同的表返回结构数据； 对一个表执行多个查询，按一个查询返回数据。 提示：组合查询和多个 WHERE 条件
多数情况下，组合相同表的两个查询所完成的工作与具有多个WHERE子句条件的一个查询所完成的工作相同。换句话说，任何具有多个WHERE子句的SELECT语句都可以作为一个组合查询，在下面可以看到这一点。
创建组合查询 可用 UNION 操作符来组合数条 SQL 查询。利用 UNION，可给出多条SELECT语句，将它们的结果组合成一个结果集。
使用UNION 使用 UNION 很简单，所要做的只是给出每条 SELECT 语句，在各条语句之间放上关键字 UNION。
举个例子，假如需要 Illinois、Indiana 和 Michigan 等美国几个州的所有顾客的报表，还想包括不管位于哪个州的所有的 Fun4All。当然可以利用 WHERE 子句来完成此工作，不过这次我们使用 UNION。
如上所述，创建 UNION 涉及编写多条 SELECT 语句。首先来看单条语句：
输入👇🏻
SELECT cust_name, cust_contact, cust_email FROM Customers WHERE cust_state IN (&amp;#39;IL&amp;#39;,&amp;#39;IN&amp;#39;,&amp;#39;MI&amp;#39;); 输出👇🏻
cust_name cust_contact cust_email ----------- ------------- ------------ Village Toys John Smith sales@villagetoys.com Fun4All Jim Jones jjones@fun4all.com The Toy Store Kim …  ]]></content></entry><entry><title>13.创建高级联结「SQL必知必会 第5版」</title><url>/database/13__creating_advanced_joins/</url><categories><category>SQL</category></categories><tags><tag>SQL必知必会</tag><tag>sql</tag><tag>MySQL</tag></tags><content type="html"><![CDATA[  前言 本系列是个人看 《SQL必知必会（第5版）》 的记录，需要的数据可以通过 建表 和 导入数据 下载导入.
正文 本节讲解另外一些联结（包括它们的含义和使用方法），介绍如何使用表别名，如何对被联结的表使用聚集函数
使用表别名 第7节 创建计算字段 介绍了如何使用别名引用被检索的表列。给列起别名的语法如下：
输入👇🏻
SELECT RTRIM(vend_name) + &amp;#39; (&amp;#39; + RTRIM(vend_country) + &amp;#39;)&amp;#39; AS vend_title FROM Vendors ORDER BY vend_name; SQL 除了可以对列名和计算字段使用别名，还允许给表名起别名。这样做有两个主要理由：
缩短 SQL 语句； 允许在一条 SELECT 语句中多次使用相同的表。 请看下面的 SELECT 语句。它与前一课例子中所用的语句基本相同，但改成了使用别名：
输入👇🏻
SELECT cust_name, cust_contact FROM Customers AS C, Orders AS O, OrderItems AS OI WHERE C.cust_id = O.cust_id AND OI.order_num = O.order_num AND prod_id = &amp;#39;RGAN01&amp;#39;; 分析👇🏻
可以看到， FROM 子句中的三个表全都有别名。 Customers AS C 使用 C作为 Customers 的别名，如此等等。这样，就可以使用省略的 C 而不用全名 Customers。在这个例子中，表别名只用于 WHERE 子句。其实它不仅能用于 WHERE 子句，还可以用于 SELECT 的列表、 ORDER BY 子句以及其他语句部分。
注意： Oracle 中没有 AS
Oracle 不支持 AS 关键字。要在 Oracle 中使用别名，可以不用 AS，简单地指定列名即可（因此，应该是 Customers C，而不是 Customers AS C）。
需要注意，表别名只在查询执行中使用。与列别名不一样，表别名不返回到客户端。
使用不同类型的联结 迄今为止，我们使用的只是内联结或等值联结的简单联结。现在来看三种其他联结：自联结（ self-join）、自然联结（ natural join）和外联 …  ]]></content></entry><entry><title>12.联结表「SQL必知必会 第5版」</title><url>/database/12__joining_tables/</url><categories><category>SQL</category></categories><tags><tag>SQL必知必会</tag><tag>sql</tag><tag>MySQL</tag></tags><content type="html"> 前言 本系列是个人看 《SQL必知必会（第5版）》 的记录，需要的数据可以通过 建表 和 导入数据 下载导入.
正文 本节会介绍什么是联结，为什么使用联结，如何编写使用联结的 SELECT 语句。
联结 SQL 最强大的功能之一就是能在数据查询的执行中联结（join）表。 联结是利用 SQL 的 SELECT 能执行的最重要的操作，很好地理解联结及其语法是学习 SQL 的极为重要的部分。
在能够有效地使用联结前，必须了解关系表以及关系数据库设计的一些基础知识。下面的介绍并不能涵盖这一主题的所有内容，但作为入门已经够了。
关系表 理解关系表，最好是来看个例子。
有一个包含产品目录的数据库表，其中每类物品占一行。对于每一种物品，要存储的信息包括产品描述、价格，以及生产该产品的供应商。
现在有同一供应商生产的多种物品，那么在何处存储供应商名、地址、联系方法等供应商信息呢？将这些数据与产品信息分开存储的理由是：
同一供应商生产的每个产品，其供应商信息都是相同的，对每个产品重复此信息既浪费时间又浪费存储空间； 如果供应商信息发生变化，例如供应商迁址或电话号码变动，只需修改一次即可； 如果有重复数据（即每种产品都存储供应商信息），则很难保证每次输入该数据的方式都相同。不一致的数据在报表中就很难利用。 关键是，相同的数据出现多次决不是一件好事，这是关系数据库设计的基础。关系表的设计就是要把信息分解成多个表，一类数据一个表。各 表通过某些共同的值互相关联（所以才叫关系数据库）。
在这个例子中可建立两个表：一个存储供应商信息，另一个存储产品信息。Vendors表包含所有供应商信息，每个供应商占一行，具有唯一的标识。此标识称为主键（primary key），可以是供应商ID 或任何其他唯一值。
Products表只存储产品信息，除了存储供应商ID（Vendors表的主键）外，它不存储其他有关供应商的信息。Vendors表的主键将 Vendors表与 Products 表关联，利用供应商ID 能从 Vendors 表中找出相应供应商的详细信息。
这样做的好处是：
供应商信息不重复，不会浪费时间和空间； 如果供应商信息变动，可以只更新 Vendors表中的单个记录，相关表中的数据不用改动； 由于数据不重复，数据显然是一致的，使得处理数据和生成报表更简单。 总之，关系数据可以有效地存储，方便 …</content></entry><entry><title>11. 使用子查询「SQL必知必会 第5版」</title><url>/database/11__working_with_subqueries/</url><categories><category>SQL</category></categories><tags><tag>SQL必知必会</tag><tag>sql</tag><tag>MySQL</tag></tags><content type="html"> 前言 本系列是个人看 《SQL必知必会（第5版）》 的记录，需要的数据可以通过 建表 和 导入数据 下载导入.
正文 本节介绍什么是子查询，如何使用它们。
子查询 SELECT语句是 SQL 的查询。我们迄今为止所看到的所有 SELECT 语句都是简单查询，即从单个数据库表中检索数据的单条语句。
查询（query）
任何 SQL 语句都是查询。但此术语一般指 SELECT 语句。
SQL 还允许创建子查询（subquery），即嵌套在其他查询中的查询。为什么要这样做呢？理解这个概念的最好方法是考察几个例子。
利用子查询进行过滤 订单存储在两个表中。每个订单包含订单编号、客户 ID、 订单日期，在 Orders 表中存储为一行。各订单的物品存储在相关的OrderItems 表中。Orders表不存储顾客信息，只存储顾客 ID。顾客的实际信息存储在Customers表中。
现在，假如需要列出订购物品 RGAN01 的所有顾客，应该怎样检索？下面列出具体的步骤。
(1) 检索包含物品 RGAN01 的所有订单的编号。
(2) 检索具有前一步骤列出的订单编号的所有顾客的ID。
(3) 检索前一步骤返回的所有顾客ID的顾客信息。
上述每个步骤都可以单独作为一个查询来执行。可以把一条 SELECT 语句返回的结果用于另一条 SELECT 语句的 WHERE 子句。
也可以使用子查询来把 3 个查询组合成一条语句。
第一条 SELECT 语句的含义很明确，它对 prod_id 为 RGAN01 的所有订单物品，检索其 order_num 列。输出列出了两个包含此物品的订单：
输入👇🏻
SELECT order_num FROM OrderItems WHERE prod_id = &amp;amp;#39;RGAN01&amp;amp;#39;; 输出👇🏻
order_num ----------- 20007 20008 现在，我们知道了哪个订单包含要检索的物品，下一步查询与订单 20007 和 20008 相关的顾客 ID。利用 第5课 介绍的 IN 子句，编写如下的 SELECT 语句：
输入👇🏻
SELECT cust_id FROM Orders WHERE order_num IN (20007,20008); 输出👇🏻
cust_id ---------- 1000000004 …</content></entry><entry><title>10. 分组数据「SQL必知必会 第5版」</title><url>/database/10__grouping_data/</url><categories><category>SQL</category></categories><tags><tag>SQL必知必会</tag><tag>sql</tag><tag>MySQL</tag></tags><content type="html"> 前言 本系列是个人看 《SQL必知必会（第5版）》 的记录，需要的数据可以通过 建表 和 导入数据 下载导入.
正文 本节介绍如何分组数据，以便汇总表内容的子集。这涉及两个新SELECT 语句子句：GROUP BY 子句和 HAVING 子句。
数据分组 从上节得知，使用 SQL 聚集函数可以汇总数据。这样，我们就能够对行进行计数，计算和与平均数，不检索所有数据就获得最大值和最小值。
目前为止的所有计算都是在表的所有数据或匹配特定的WHERE 子句的数据上进行的。比如下面的例子返回供应商 DLL01 提供的产品数目：
输入👇🏻
SELECT COUNT(*) AS num_prods FROM Products WHERE vend_id = &amp;amp;#39;DLL01&amp;amp;#39;; 输出👇🏻
num_prods ----------- 4 如果要返回每个供应商提供的产品数目，该怎么办？或者返回只提供一项产品的供应商的产品，或者返回提供 10 个以上产品的供应商的产品， 怎么办？
这就是分组大显身手的时候了。使用分组可以将数据分为多个逻辑组， 对每个组进行聚集计算。
创建分组 分组是使用 SELECT 语句的 GROUP BY 子句建立的。理解分组的最好办法是看一个例子：
输入👇🏻
SELECT vend_id, COUNT(*) AS num_prods FROM Products GROUP BY vend_id; 输出👇🏻
vend_id num_prods ------- --------- BRS01 3 DLL01 4 FNG01 2 分析👇🏻
上面的 SELECT 语句指定了两个列：vend_id 包含产品供应商的 ID， num_prods 为计算字段（用 COUNT(*)函数建立）。GROUP BY 子句指示DBMS 按 vend_id 排序并分组数据。这就会对每个 vend_id 而不是整个表计算num_prods 一次。从输出中可以看到，供应商 BRS01 有 3 个产品，供应商 DLL01 有 4 个产品，而供应商 FNG01 有 2 个产品。
因为使用了 GROUP BY，就不必指定要计算和估值的每个组了。系统会自动完成。GROUP BY 子句指示 DBMS 分组数据，然后对每个组而不是整个结果集进行聚集。
在使用 GROUP BY 子句前，需要知 …</content></entry><entry><title>9. 汇总数据「SQL必知必会 第5版」</title><url>/database/9__summarizing_data/</url><categories><category>SQL</category></categories><tags><tag>SQL必知必会</tag><tag>sql</tag><tag>MySQL</tag></tags><content type="html"> 前言 本系列是个人看 《SQL必知必会（第5版）》 的记录，需要的数据可以通过 建表 和 导入数据 下载导入.
正文 本节介绍什么是 SQL 的聚集函数，如何利用它们汇总表的数据。
聚集函数 我们经常需要汇总数据而不用把它们实际检索出来，为此 SQL 提供了专门的函数。使用这些函数，SQL 查询可用于检索数据，以便分析和报表生成。这种类型的检索例子有：
确定表中行数（或者满足某个条件或包含某个特定值的行数）； 获得表中某些行的和； 找出表列（或所有行或某些特定的行）的最大值、最小值、平均值。 上述例子都需要汇总出表中的数据，而不需要查出数据本身。因此，返回实际表数据纯属浪费时间和处理资源（更不用说带宽了）。再说一遍，我们实际想要的是汇总信息。
为方便这种类型的检索，SQL 给出了5个聚集函数，见下表。这些函数能进行上述检索。与前一章介绍的数据处理函数不同，SQL 的聚集函数在各种主要 SQL 实现中得到了相当一致的支持。
聚集函数（aggregate function）
对某些行运行的函数，计算并返回一个值。
SQL聚集函数 函数 说明 AVG() 返回某列的平均值 COUNT() 返回某列的行数 MAX() 返回某列的最大值 MIN() 返回某列的最小值 SUM() 返回某列值之和 下面说明各函数的使用。
AVG()函数 AVG()通过对表中行数计数并计算其列值之和，求得该列的平均值。AVG() 可用来返回所有列的平均值，也可以用来返回特定列或行的平均值。
下面的例子使用 AVG()返回 Products 表中所有产品的平均价格：
输入👇🏻
SELECT AVG(prod_price) AS avg_price FROM Products; 输出👇🏻
avg_price ------------- 6.823333 分析👇🏻
此 SELECT 语句返回值 avg_price，它包含 Products 表中所有产品的平均价格。如 第7节 所述，avg_price 是一个别名。
AVG()也可以用来确定特定列或行的平均值。下面的例子返回特定供应商所提供产品的平均价格：
输入👇🏻
SELECT AVG(prod_price) AS avg_price FROM Products WHERE vend_id = &amp;amp;#39;DLL01&amp;amp;#39;; 输出👇🏻 …</content></entry><entry><title>8. 使用函数处理数据「SQL必知必会 第5版」</title><url>/database/8__using_data_manipulation_functions/</url><categories><category>SQL</category></categories><tags><tag>SQL必知必会</tag><tag>sql</tag><tag>MySQL</tag></tags><content type="html"> 前言 本系列是个人看 《SQL必知必会（第5版）》 的记录，需要的数据可以通过 建表 和 导入数据 下载导入.
正文 本节介绍什么是函数，DBMS 支持何种函数，以及如何使用这些函数； 还将讲解为什么 SQL 函数的使用可能会带来问题。
函数 与大多数其他计算机语言一样，SQL 也可以用函数来处理数据。函数一般是在数据上执行的，为数据的转换和处理提供了方便。
上节中用来去掉字符串尾的空格的 RTRIM()就是一个函数。
函数带来的问题 在学习并进行实践之前，你应该了解使用 SQL 函数所存在的问题。
与几乎所有 DBMS 都等同地支持 SQL 语句（如 SELECT）不同，每一个DBMS 都有特定的函数。事实上，只有少数几个函数被所有主要的 DBMS 等同地支持。虽然所有类型的函数一般都可以在每个 DBMS 中使用，但 各个函数的名称和语法可能极其不同。为了说明可能存在的问题。列出了 3 个常用的函数及其在各个 DBMS 中的语法：
DBMS函数的差异 函数 语法 提取字符串的组成部分 DB2、Oracle、PostgreSQL 和 SQLite 使用 SUBSTR() ；
MariaDB、 MySQL 和 SQL Server 使用 SUBSTRING()； 数据类型转换 Oracle 使用多个函数，每种类型的转换有一个函数；
DB2和 PostgreSQL 使用 CAST()；
MariaDB、MySQL 和 SQL Server 使用 CONVERT()； 取当前日期 DB2和 PostgreSQL 使用 CURRENT_DATE；
MariaDB 和 MySQL 使用 CURDATE()；
Oracle 使用 SYSDATE；
SQL Server 使用 GETDATE()；
SQLite 使用 DATE()； 可以看到，与 SQL 语句不一样，SQL 函数不是可移植的。这意味着为特定 SQL 实现编写的代码在其他实现中可能不能用。
可移植（portable）
所编写的代码可以在多个系统上运行。
为了代码的可移植，许多 SQL 程序员不赞成使用特定于实现的功能。虽然这样做很有好处，但有的时候并不利于应用程序的性能。如果不使用这些函数，编写某些应用程序代码会很艰难。必须利用其他方法来实现DBMS 可以非常有效完成的工作。
提示：是否应该使用函数？ 现在，你面临 …</content></entry><entry><title>7. 创建计算字段「SQL必知必会 第5版」</title><url>/database/7__creating_calculated_fields/</url><categories><category>SQL</category></categories><tags><tag>SQL必知必会</tag><tag>sql</tag><tag>MySQL</tag></tags><content type="html"> 前言 本系列是个人看 《SQL必知必会（第5版）》 的记录，需要的数据可以通过 建表 和 导入数据 下载导入.
正文 本节介绍什么是计算字段，如何创建计算字段，以及如何从应用程序中使用别名引用它们
计算字段 存储在数据库表中的数据一般不是应用程序所需要的格式，下面举几个例子。
需要显示公司名，同时还需要显示公司的地址，但这两个信息存储在不同的表列中。 城市、州和邮政编码存储在不同的列中（应该这样），但邮件标签打印程序需要把它们作为一个有恰当格式的字段检索出来。 列数据是大小写混合的，但报表程序需要把所有数据按大写表示出来。 物品订单表存储物品的价格和数量，不存储每个物品的总价格（用价格乘以数量即可）。但为打印发票，需要物品的总价格。 需要根据表数据进行诸如总数、平均数的计算。 在上述每个例子中，存储在表中的数据都不是应用程序所需要的。我们需要直接从数据库中检索出转换、计算或格式化过的数据，而不是检索出数据，然后再在客户端应用程序中重新格式化。
这就是计算字段可以派上用场的地方了。与前几课介绍的列不同，计算字段并不实际存在于数据库表中。计算字段是运行时在 SELECT 语句内创建的。
字段（field）
基本上与列（column）的意思相同，经常互换使用，不过数据库列一般称为列，而字段这个术语通常在计算字段这种场合下使用。
需要特别注意，只有数据库知道 SELECT 语句中哪些列是实际的表列，哪些列是计算字段。从客户端（如应用程序）来看，计算字段的数据与其他列的数据的返回方式相同。
提示：客户端与服务器的格式
在 SQL 语句内可完成的许多转换和格式化工作都可以直接在客户端应用程序内完成。但一般来说，在数据库服务器上完成这些操作比在客户端中完成要快得多。
拼接字段 为了说明如何使用计算字段，我们来举一个简单例子，创建由两列组成的标题。
Vendors 表包含供应商名和地址信息。假如要生成一个供应商报表，需要在格式化的名称（位置）中列出供应商的位置。
此报表需要一个值，而表中数据存储在两个列 vend_name和vend_country中。此外，需要用括号将vend_country 括起来，这些东西都没有存储在数据库表中。这个返回供应商名称和地址的 SELECT 语句很简单，但我们是如何创建这个组合值的呢？
拼接（concatenate）
将值联结到一起（将一个值附加到 …</content></entry><entry><title>6.用通配符进行过滤「SQL必知必会 第5版」</title><url>/database/6__using_wildcard_filtering/</url><categories><category>SQL</category></categories><tags><tag>SQL必知必会</tag><tag>sql</tag><tag>mySql</tag></tags><content type="html"> 前言 本系列是个人看 《SQL必知必会（第5版）》 的记录，需要的数据可以通过 建表 和 导入数据 下载导入.
正文 本节介绍什么是通配符、如何使用通配符，以及怎样使用 LIKE 操作符进行通配搜索，以便对数据进行复杂过滤。
LIKE 操作符 前面介绍的所有操作符都是针对已知值进行过滤的。不管是匹配一个值还是多个值，检验大于还是小于已知值，或者检查某个范围的值，其共同点是过滤中使用的值都是已知的。
但是，这种过滤方法并不是任何时候都好用。例如，怎样搜索产品名中包含文本 bean bag的所有产品？用简单的比较操作符肯定不行，必须使用通配符。利用通配符，可以创建比较特定数据的搜索模式。在这个例子中，如果你想找出名称包含 bean bag 的所有产品，可以构造一个通配符搜索模式，找出在产品名的任何位置出现 bean bag 的产品。
通配符（wildcard）
用来匹配值的一部分的特殊字符。
搜索模式（search pattern）
由字面值、通配符或两者组合构成的搜索条件
通配符本身实际上是 SQL 的 WHERE 子句中有特殊含义的字符，SQL 支持几种通配符。为在搜索子句中使用通配符，必须使用 LIKE 操作符。LIKE 指示 ，后跟的搜索模式利用通配符匹配而不是简单的相等匹配进行比较。
谓词（predicate）
操作符何时不是操作符？答案是，它作为谓词时。从技术上说，LIKE 是谓词而不是操作符。虽然最终的结果是相同的，但应该对此术语有所了解，以免在 SQL 文献或手册中遇到此术语时不知所云。
通配符搜索只能用于文本字段（字符串），非文本数据类型字段不能使用通配符搜索。
百分号（%）通配符 最常使用的通配符是百分号（%）。在搜索串中，%表示任何字符出现任意次数。例如，为了找出所有以词 Fish 起头的产品，可写以下的 SELECT 语句：
输入👇🏻
SELECT prod_id, prod_name FROM Products WHERE prod_name LIKE &amp;amp;#39;Fish%&amp;amp;#39;; 输出👇🏻
prod_id prod_name ------- ------------------ BNBG01 Fish bean bag toy 分析👇🏻
此例子使用了搜索模式Fish%。在执行这条子句时，将检索任意以Fish起头的词。%告诉 DBMS …</content></entry><entry><title>5.高阶数据过滤「SQL必知必会 第5版」</title><url>/database/5__advanced_data_filtering/</url><categories><category>SQL</category></categories><tags><tag>SQL必知必会</tag><tag>sql</tag><tag>mySql</tag></tags><content type="html"> 前言 本系列是个人看 《SQL必知必会（第5版）》 的记录，需要的数据可以通过 建表 和 导入数据 下载导入.
正文 这一节讲授如何组合 WHERE 子句以建立功能更强、更高级的搜索条件。 我们还将学习如何使用 NOT 和 IN 操作符。
组合 WHERE 子句 上一节介绍的所有 WHERE 子句在过滤数据时使用的都是单一的条件。为 了进行更强的过滤控制，SQL 允许给出多个 WHERE 子句。这些子句有两种使用方式，即以 AND子句或 OR子句的方式使用。
操作符（operator）
用来联结或改变 WHERE 子句中的子句的关键字，也称为逻辑操作符 （logical operator）。
AND操作符 要通过不止一个列进行过滤，可以使用 AND操作符给 WHERE子句附加条件。
输入👇🏻
SELECT prod_id, prod_price, prod_name FROM Products WHERE vend_id = &amp;amp;#39;DLL01&amp;amp;#39; AND prod_price &amp;amp;lt;= 4; 分析👇🏻
此 SQL 语句检索由供应商 DLL01制造且价格小于等于 4 美元的所有产品的名称和价格。这条 SELECT语句中的 WHERE子句包含两个条件，用 AND 关键字联结在一起。AND 指示 DBMS 只返回满足所有给定条件的行。如果某个产品由供应商 DLL01制造，但价格高于 4 美元，则不检索它。类似地，如果产品价格小于 4 美元，但不是由指定供应商制造的也不被检索。这条 SQL 语句产生的输出如下：
输出👇🏻
prod_id prod_price prod_name ------- ---------- -------------------- BNBG02 3.4900 Bird bean bag toy BNBG01 3.4900 Fish bean bag toy BNBG03 3.4900 Rabbit bean bag toy AND
用在 WHERE 子句中的关键字，用来指示检索满足所有给定条件的行。
这个例子只包含一个 AND 子句，因此只有两个过滤条件。可以增加多个过滤条件，每个条件间都要使用 AND关键字。
说明：没有 ORDER BY 子句 为了节省空间，也为了减少你的输入，很多例子里省略了 ORDER BY子句。因此，你的输出完 …</content></entry><entry><title>4.过滤数据「SQL必知必会 第5版」</title><url>/database/4__filtering_data/</url><categories><category>SQL</category></categories><tags><tag>SQL必知必会</tag><tag>sql</tag><tag>mySql</tag></tags><content type="html"> 前言 本系列是个人看 《SQL必知必会（第5版）》 的记录，需要的数据可以通过 建表 和 导入数据 下载导入.
正文 这一节将讲授如何使用 SELECT 语句的 WHERE 子句指定搜索条件。
使用 WHERE 子句 数据库表一般包含大量的数据，很少需要检索表中的所有行。通常只会根据特定操作或报告的需要提取表数据的子集。只检索所需数据需要指定搜索条件（ search criteria），搜索条件也称为过滤条件（ filter condition）。
在 SELECT 语句中，数据根据 WHERE 子句中指定的搜索条件进行过滤。
WHERE 子句在表名（ FROM 子句）之后给出
输入👇🏻
SELECT prod_name, prod_price FROM Products WHERE prod_price = 3.49; 分析👇
这条语句从 products 表中检索两个列，但不返回所有行，只返回 prod_price 值为 3.49 的行
输出👇
prod_name prod_price ------------------- ---------- Fish bean bag toy 3.49 Bird bean bag toy 3.49 Rabbit bean bag toy 3.49 这个示例使用了简单的相等检验：检查这一列的值是否为指定值，据此过滤数据。不过， SQL 不只能测试等于，还能做更多的事情。
提示：有多少个 0？
你在练习这个示例时，会发现显示的结果可能是 3.49、 3.490、 3.4900等。出现这样的情况，往往是因为 DBMS 指定了所使用的数据类型及其默认行为。所以，如果你的输出可能与书上的有点不同，不必焦虑，毕竟从数学角度讲， 3.49 和 3.4900 是一样的。
提示： SQL 过滤与应用过滤
数据也可以在应用层过滤。为此， SQL 的 SELECT 语句为客户端应用检索出超过实际所需的数据，然后客户端代码对返回数据进行循环，提取出需要的行。
通常，这种做法极其不妥。优化数据库后可以更快速有效地对数据进行过滤。而让客户端应用（或开发语言）处理数据库的工作将会极大地影响应用的性能，并且使所创建的应用完全不具备可伸缩性。此外，如果在客户端过滤数据，服务器不得不通过网络发送多余的数据，这将导致网络带宽的浪费。
注意： WHERE 子句的 …</content></entry><entry><title>3.排序检索数据「SQL必知必会 第5版」</title><url>/database/3__sorting_retrieved_data/</url><categories><category>SQL</category></categories><tags><tag>SQL必知必会</tag><tag>sql</tag><tag>mySql</tag></tags><content type="html"> 前言 本系列是个人看 《SQL必知必会（第5版）》 的记录，需要的数据可以通过 建表 和 导入数据 下载导入.
正文 这一节讲授如何使用SELECT语句的ORDER BY子句，根据需要排序检索出的数据
排序数据 下面的 SQL 语句返回某个数据库表的单个列，输出并没有特定的顺序。
输入👇🏻
SELECT prod_name FROM Products; 输出👇
prod_name ------------------- Fish bean bag toy Bird bean bag toy Rabbit bean bag toy 8 inch teddy bear 12 inch teddy bear 18 inch teddy bear Raggedy Ann King doll Queen doll 其实，检索出的数据并不是随机显示的。如果不排序，数据一般将以它在表中出现的顺序显示，这有可能是数据最初添加到表中的顺序。但是，如果数据随后进行过更新或删除，那么这个顺序将会受到 DBMS 重用回收存储空间的方式的影响。因此，如果不明确控制的话，则最终的结果不能（也不应该）依赖该排序顺序。关系数据库设计理论认为，如果不明确规定排序顺序，则不应该假定检索出的数据的顺序有任何意义。
子句（clause） SQL 语句由子句构成，有些子句是必需的，有些则是可选的。一个子句通常由一个关键字加上所提供的数据组成。子句的例子有我们在前一节看到的 SELECT 语句的 FROM 子句。
为明确地排序用 SELECT 语句检索出的数据，可使用 ORDER BY 子句。ORDER BY 子句取一个或多个列的名字，据此对输出进行排序。
输入👇🏻
SELECT prod_name FROM Products ORDER BY prod_name; 分析👇 除了指示 DBMS 软件对 prod_name 列以字母顺序排序数据的 ORDER BY子句外，这条语句与前面的语句相同。
输出👇
prod_name -------------------- 12 inch teddy bear 18 inch teddy bear 8 inch teddy bear Bird bean bag toy Fish bean bag toy King doll Queen doll Rabbit bean …</content></entry><entry><title>2.检索数据「SQL必知必会 第5版」</title><url>/database/2__retrieving_data/</url><categories><category>SQL</category></categories><tags><tag>SQL必知必会</tag><tag>sql</tag><tag>mySql</tag></tags><content type="html"> 前言 本系列是个人看 《SQL必知必会（第5版）》 的记录，需要的数据可以通过 建表 和 导入数据 下载导入.
正文 SELECT语句 SQL语句是有简单的英语单词构成，这些单词称为关键字，每个SQL语句都是由一个或多个关键字构成。常用的就是SELECT语句，用图是从一个或多个表中检索数据
关键字（keyword）
作为SQL组成部分的保留字。关键字不能用作表或列的名字。 SQL保留字 列出了经常使用的保留字。
为了使用SELECT检索表数据，必须至少给我两条信息——想选择什么，以及从什么地方选择。
检索单个列 输入👇🏻
SELECT prod_name FROM Products; 分析👇
上述语句利用 SELECT 语句从 Products 表中检索一个名为 prod_name的列。所需的列名写在 SELECT 关键字之后， FROM 关键字指出从哪个表中检索数据。
输出👇
prod_name ------------------- Fish bean bag toy Bird bean bag toy Rabbit bean bag toy 8 inch teddy bear 12 inch teddy bear 18 inch teddy bear Raggedy Ann King doll Queen doll 说明：未排序数据
如果你自己试验这个查询，可能会发现显示输出的数据顺序与这里的不同。出现这种情况很正常。如果没有明确排序查询结果，则返回的数据没有特定的顺序。只要返回相同数目的行，就是正常的
如上的一条简单 SELECT 语句将返回表中的所有行。数据没有过滤（过滤将得出结果集的一个子集），也没有排序。
提示：结束 SQL 语句
多条SQL语句必须以分号（ ； ）分隔。单条SQL语句后是否加分号依据DBMS需要而定，多数不需要。
提示：SQL 语句和大小写
请注意， SQL语句不区分大小写，因此 SELECT 与 select 是相同的。同样，写成 Select 也没有关系。许多 SQL开发人员喜欢对SQL关键字使用大写，而对列名和表名使用小写，这样做代码更易于阅读和调试。不过，一定要认识到虽然 SQL 是不区分大小写的，但是表名、列名和值可能有所不同（这有赖于具体的 DBMS 及其如何配置）。
提示：使用空格
在处理 SQL语句时，其中所有空格都被 …</content></entry><entry><title>SQL保留字「SQL必知必会 第5版」</title><url>/database/database_keyword/</url><categories><category>SQL</category></categories><tags/><content type="html"> 前言 SQL 是由关键字组成的语言，关键字是一些用于执行SQL操作的特殊词汇。在命名数据库、表、列和其他数据库对象时，一定不要使用这些关键字。因此，这些关键字是一定要保留的。
关键字随不同的 DBMS 而变化，并非下面的所有关键字都被所有DBMS 采用。 许多 DBMS 扩展了 SQL 保留字，使其包含专门用于实现的术语。多数DBMS 专用的关键字未列在下面。 为保证以后的兼容性和可移植性，应避免使用这些保留字，即使它们不是你使用的 DBMS 的保留字。 ABORT AS BETWEEN ABSOLUTE ASC BIGINT ACTION ASCENDING BINARY ACTIVE ASSERTION BIT ADD AT BLOB AFTER AUTHORIZATION BOOLEAN ALL AUTO BOTH ALLOCATE AUTO-INCREMENT BREAK ALTER AUTOINC BROWSE ANALYZE AVG BULK AND BACKUP BY ANY BEFORE BYTES ARE BEGIN CACHE CALL CURRENT EXCEPT CASCADE CURRENT_DATE EXCEPTION CASCADED CURRENT_TIME EXEC CASE CURRENT_TIMESTAMP EXECUTE CAST CURRENT_USER EXISTS CATALOG CURSOR EXIT CHANGE DATABASE EXPLAIN CHAR DATABASES EXTEND CHARACTER DATE EXTERNAL CHARACTER_LENGTH DATETIME EXTRACT CHECK DAY FALSE CHECKPOINT DBCC FETCH CLOSE DEALLOCATE FIELD CLUSTER DEBUG FIELDS CLUSTERED DEC FILE COALESCE DECIMAL FILLFACTOR COLLATE DECLARE FILTER COLUMN DEFAULT FLOAT COLUMNS DELETE FLOPPY COMMENT DENY FOR COMMIT DESC FORCE COMMITTED DESCENDING FOREIGN COMPUTE DESCRIBE FOUND COMPUTED DISCONNECT FREETEXT CONDITIONAL DISK FREETEXTTABLE CONFIRM DISTINCT FROM CONNECT DISTRIBUTED FULL CONNECTION DIV FUNCTION CONSTRAINT DO GENERATOR CONSTRAINTS DOMAIN GET CONTAINING DOUBLE GLOBAL CONTAINS DROP GO CONTAINSTABLE DUMMY GOTO CONTINUE DUMP GRANT CONTROLROW ELSE GROUP CONVERT ELSEIF HAVING COPY ENCLOSED HOLDLOCK COUNT END HOUR CREATE ERRLVL IDENTITY CROSS ERROREXIT IF CSTRING ESCAPE IN CUBE ESCAPED INACTIVE INDEX MIRROREXIT PERM INDICATOR MODULE PERMANENT INFILE MONEY PIPE INNER MONTH PLAN INOUT MOVE POSITION INPUT NAMES PRECISION INSENSITIVE NATIONAL PREPARE INSERT NATURAL PRIMARY INT NCHAR PRINT INTEGER NEXT PRIOR INTERSECT NEW PRIVILEGES INTERVAL NO PROC INTO NOCHECK PROCEDURE IS NONCLUSTERED PROCESSEXIT ISOLATION NONE PROTECTED JOIN NOT PUBLIC KEY NULL PURGE KILL NULLIF RAISERROR LANGUAGE NUMERIC READ LAST OF READTEXT LEADING OFF REAL LEFT OFFSET REFERENCES LENGTH OFFSETS REGEXP LEVEL ON RELATIVE LIKE ONCE RENAME LIMIT ONLY REPEAT LINENO OPEN REPLACE LINES OPTION REPLICATION LISTEN OR REQUIRE LOAD ORDER RESERV LOCAL OUTER RESERVING LOCK OUTPUT RESET LOGFILE OVER RESTORE LONG OVERFLOW RESTRICT LOWER OVERLAPS RETAIN MANUAL PAD RETURN MATCH PAGE RETURNS MAX PAGES REVOKE MERGE PARAMETER RIGHT MESSAGE PARTIAL ROLLBACK MIN PASSWORD ROLLUP MINUTE PERCENT ROWCOUNT RULE STARTING UNTIL SAVE STARTS UPDATE SAVEPOINT STATISTICS UPDATETEXT SCHEMA SUBSTRING UPPER SECOND SUM USAGE SECTION SUSPEND USE SEGMENT TABLE USER SELECT TABLES USING SENSITIVE TEMP VALUE SEPARATOR TEMPORARY VALUES SEQUENCE TEXT VARCHAR SESSION_USER TEXTSIZE VARIABLE SET THEN VARYING SETUSER TIME VERBOSE SHADOW TIMESTAMP VIEW SHARED TO VOLUME SHOW TOP WAIT SHUTDOWN TRAILING WAITFOR SINGULAR TRAN WHEN SIZE TRANSACTION WHERE SMALLINT TRANSLATE WHILE SNAPSHOT TRIGGER WITH SOME TRIM WORK SORT TRUE WRITE SPACE TRUNCATE WRITETEXT SQL TYPE XOR SQLCODE UNCOMMITTED YEAR SQLERROR UNION ZONE STABILITY UNIQUE</content></entry><entry><title>1.了解SQL「SQL必知必会 第5版」</title><url>/database/1__understanding_sql/</url><categories><category>SQL</category></categories><tags><tag>SQL必知必会</tag><tag>sql</tag><tag>mySql</tag></tags><content type="html"> 前言 本系列是个人看 《SQL必知必会（第5版）》 的记录，需要的数据可以通过 建表 和 导入数据 下载导入.
正文 数据库 数据库这个术语的用法很多，从 SQL 的角度来看，数据库是一个以某种有组织的方式存储的数据集合。最简单的办法是将数据库想象为一个文件柜。
数据库（database）
保存有组织的数据的容器（通常是一个文件或一组文件）。
注意：误用导致混淆
人们通常用数据库这个术语来代表他们使用的数据库软件，这是不正确的，也因此产生了许多混淆。确切地说，数据库软件应称为数据库管理系统（DBMS）。
表 表是一种结构化的文件，可用来存 储某种特定类型的数据。表可以保存顾客清单、产品目录，或者其他信息清单。
表（table）
某种特定类型数据的结构化清单。
数据库中的每个表都有一个名字来标识自己。这个名字是唯一的，即数据库中没有其他表具有相同的名字。
列和数据类型 表由列组成。列存储表中某部分的信息。
列（column）
表中的一个字段。所有表都是由一个或多个列组成的。
数据库中每个列都有相应的数据类型。数据类型（datatype）定义了列可以存储哪些数据种类。举个🌰子，如果列中存储的是数字（或许是订单中的物品数），则相应的数据类型应该为数值类型。如果列中存储的是日期、文本、注释、金额等，则应该规定好恰当的数据类型。
行 表中的数据是按行存储的，所保存的每个记录存储在自己的行内。如果将表想象为网格，网格中垂直的列为表列，水平行为表行。
主键 表中每一行都应该有一列（或几列）可以唯一标识自己。 主键用来表示一个特定的行。没有主键，更新或删除表中特定行就极为困难，因为你不能保证操作只涉及相关的行，没有伤及无辜。
表中的任何列都可以作为主键，只要它满足以下条件：
任意两行都不具有相同的主键值； 每一行都必须具有一个主键值（主键列不允许空值 NULL）； 主键列中的值不允许修改或更新； 主键值不能重用（如果某行从表中删除，它的主键不能赋给以后的新行）。 主键通常定义在表的一列上，但并不是必须这么做，也可以一起使用多个列作为主键。在使用多列作为主键时，上述条件必须应用到所有列，所有列值的组合必须是唯一的（但其中单个列的值可以不唯一）。还有一种非常重要的键，称为外键，
什么是 SQL SQL（发音为字母 S-Q-L 或 sequel）是 Structured Query …</content></entry><entry><title>用Hugo搭建博客</title><url>/post/create_blog/</url><categories/><tags/><content type="html"><![CDATA[  前言 关于博客的创建，折腾过很多框架， hexo 、 Gridea 、最后使用了 hugo 。hexo依赖Node.js，庞大node_modules安装和运行相对来说都不如hugo快速，至于Gridea，一开始用的时候发现这个用起来真舒适，只要下载客户端后，配置一下即可，剩下的就编写博客了，后来从windows换到mac的时候发现，Gridea不支持迁移，完全要自己手动搬运。至此，决定试试hugo，感觉还不错。
搭建 安装Hugo Mac下直接使用Homebrew安装： brew install hugo window下下载安装包，配置环境变量即可 生成站点 使用Hugo快速生成站点，比如想创建的项目名为blog的项目：
hugo new site ./blog 这样就在当前目录生成了一个blog的站点，进去目录：
cd blog 目录结构如下：
&gt; blog/ # 根目录 &gt; themes/ # 主体目录 &gt; static/ # 静态文件 &gt; layouts/ # 布局模版 &gt; i18n/ # 字体 &gt; data/ # 目录用来存储Hugo生成网站时应用的配置文件 &gt; content/ # 博客md文件 &gt; assets/ # &gt; archetypes/ # 预设置的文件模板头部 hugo.toml # 配置 创建博客 创建第一篇文章，放到post目录
hugo new post/first.md 打开编辑post/first.md
--- title: &#34;hello world&#34; date: 2020-10-24T15:51:17+08:00 draft: true --- # hello world 1. 第一篇文章 2. 加油 安装皮肤主题 到皮肤列表找一个中意的皮肤，为方便日后皮肤更新，可以使用git submodule的方式添加到站点中：
git submodule add https://github.com/adityatelange/hugo-PaperMod.git themes/hugo-PaperMod 注：如果网站要部署到Gitee pages中，上面的github要换成gitee的
git submodule add https://gitee.com/duchenpaul/hugo-PaperMod.git themes/hugo-PaperMod 更新皮肤主题：
git submodule update --remote --merge 配置皮肤主题： hugo.toml需要按照各自主题的配置即可。如果需要区分环境，比如站点不是配置到根目录而是子目录/blog之下，把么就需要在开发环境时baseURL: /，而部署后的生产环境为baseURL: /blog，这个时候只需要在根目录创建以下目录结构：
&gt; blog/ &gt; config/ &gt; _default/ config.yaml &gt; production/ config.yaml &gt; ... _default下的配置是默认的，当部署至生产环境时，会被production下的配置覆盖
运行Hugo 在项目根目录下运行：
hugo server 浏览器打开：http://localhost:1313，就可以看到效果了。
部署 之前部署在github上，国内访问慢，现在可以配置在gitee上面，运行：
hugo 静态页面会生成到public目录，push代码到gitee，在gitee上面开启Gitee pages，博客就搭建完成了。
  ]]></content></entry><entry><title>2020年5月面试纪要</title><url>/post/2020-05-12/</url><categories/><tags/><content type="html"> 前言 今天面了一家国企，具体哪家公司就不提了😂。本人17年毕业，但是16年底就在目前的公司一直工作，面试环节可以说是薄弱的可怜😪。面试官直指痛点，技术可以，但是表述不清楚。面试嘛，大部分都是聊着造火箭的技术，到公司之后拧螺丝。但是没办法，这是现实。因此我努力回忆起了一些今天面试的内容，整理一下用作记录，接下来步入正题。
注意 本文偏重理论和原理，没有过多的代码和图解，读起来可能有些枯燥，刚开始写博客，多多批评！😝
面试主要内容： SPA应用性能优化 插槽的使用 子父组件生命周期的加载顺序 history和hash区别以及原理 ES6的map使用 聊一下ES5和ES6继承 兄弟组件如何传值 vuex如果实现状态管理，详细描述一下实现过程 暂时只能回想起这么多，看到这里你是否和我一样觉得这些都是我们日常用到的，但是深究其底层原理，又觉得好像只能说点皮毛。没关系，下面是我整理的资料，希望对各位面试的时候有用！
面试题目解析 前端性能优化 减小代码体积 首先是开发时，我们主要对自己代码的执行有认知，怎么写，才能做到代码量最小并且执行的更快。 v-if和v-show，v-if是惰性的，只有条件为真的时候才会渲染，v-show是只要执行到此处，就会渲染元素，区分场景 computed 和 watch，computed依赖其他数据进行数值计算，避免每次获取值时重新计算；watch是对数据的监听，对数据操作过多时，允许执行异步操作，限制操作频率，设置中间态。
v-for遍历，务必为item 添加key，方便 Vue.js 内部机制精准找到该条列表数据。当 state 更新时，新的状态值和旧的状态值对比，较快地定位到 diff ；且v-for比 v-if优先级高，尽量在v-for中使用v-if以为可能只修改一个值，就需要遍历整个数据表，严重影响速度
图片资源懒加载，使用 vue-lazyload
路由懒加载，避免首页首页长时间白屏，开发路由时使用 import(&amp;#39;./***.vue&amp;#39;)
第三方插件的按需引入，使用 babel-plugin-component
其次就是 webpack 为我们提供的方法，我们尽管使用即可 对图片进行压缩，使用 image-webpack-loader
提取公共代码，Webpack 内置了专门用于提取多个Chunk …</content></entry><entry><title>hello world</title><url>/post/hello_world/</url><categories/><tags/><content type="html">
前言 程序员退休后决定练习书法， 于是重金购买文房四宝。一日，饭后突生雅兴一番研墨拟纸并点上上好檀香，定神片刻 ，泼墨挥毫， 郑重地写下一行字：hello world！
正文 我经常逛一些大牛的博客，阮一峰、廖雪锋，还逛虎嗅，36K等资讯网站，正应了那句“秀才不出门，便知天下事”。在当今互联网飞速发展的时代，作为一位IT人员，不学习就意味着被淘汰，即使你现在很牛X。
下面是前端的发展史：
- 1989 html正式诞生，由物理学家蒂姆·伯纳斯·李为了方便学术文档的分享而创造，这也是前端的起始时间。 - 1994.10.13 Mosaic Netscape 0.9正式发布，一代浏览器霸主开始展露它的锋芒。 - 1994.10 Web技术领域最具权威和影响力的国际中立性技术标准机构正式成立，创立者就是html的创造者大神蒂姆·伯纳斯·李。 - 1995.05 前端中最重要的成员JavaScript（原名LiveScript）诞生，创造者是网景的布兰登·艾奇。他仅仅用了10天的时间就- 完成了这项创举。 - 1995.12.24 html2.0标准由IETF正式发布。 - 1996.08 JScript1.0由微软正式发布，矛头直指网景的JavaScript，成就IE的同时也开启了自己声名狼藉之路。 - 1996 ActiveX由微软正式发布，虽然很蹩脚，但是基于这个技术，我们终于可以在IE上完成桌面端程序的任务了。 - 1996.12.17 W3C正式发布了CSS1标准，从此，前端有了自己的样式规范。 - 1997.02.14 W3C正式发布了html3.2标准，丰富了html的语义。 - 1997.05 ECMAScript1正式发布，在浏览器大战中被玩坏的程序员们终于等来了他们的第一版JS规范。 - 1997.12.18 W3C正式发布了html4.0标准，这也是我们使用时间最长的html版本。 - 1998.05 ECMAScript2正式发布。 - 1998 IE5.0引入了XMLHttpRequest技术，实现了异步调用服务器的功能。但是，谁也没有想到它会带来一场前端革命。 - 1999.05 W3C正式发布了CSS3标准中的首批模块（CSS3标准并不是一次性发布，而是分模块发布的）。 - 1999.12 ECMAScript3正式发布。 - …</content></entry></search>